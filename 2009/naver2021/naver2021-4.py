# 미로탈출 왼손법칙

# 0,0 에서 시작 n-1, n-1 에 도착하면 끝

ex1 = [[0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 0]] # 10
ex2 = [[0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0]] # 32
ex3 = [[0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0]] # 24
ex4 = [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0]] # 22

def solution(maze):
    dir = {(0,-1):[(1,0),(0,-1),(-1,0),(0,1)], (-1,0):[(0,-1), (-1,0), (0,1), (1,0)], (0,1):[(-1,0), (0,1), (1,0),(0,-1)], (1,0):[(0,1), (1,0),(0,-1),(-1,0)]}
    current_dic = (0,1)
    answer = 0
    size = len(maze)
    maze[size-1][size-1] = 2 # goal 지정
    qu = [(0,0)]
    while qu:
        answer+=1
        p = qu.pop(0)
        for i in dir[current_dic]:
            np = (p[0]+i[0], p[1]+i[1])
            if -1<np[0]<size and -1<np[1]<size:
                if maze[np[0]][np[1]] == 2:
                    return answer
                elif maze[np[0]][np[1]] == 0:
                    current_dic = i
                    qu.append(np)
                    break
    return answer

print(solution(ex4))